package dao

import (
	"context"
	"testing"
	"time"

	"github.com/gibson-sec/gibson-framework-2/internal/test"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestPluginStatsDAO_Create(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)

	tests := []struct {
		name    string
		stats   *PluginStats
		wantErr bool
	}{
		{
			name: "successful plugin execution",
			stats: &PluginStats{
				PluginID:       "sql-injection-scanner",
				ScanID:         "scan-001",
				ExecutionTime:  1500, // 1.5 seconds in milliseconds
				MemoryUsage:    67108864, // 64MB in bytes
				FindingsCount:  3,
				Status:         "success",
				StartTime:      time.Now().Add(-2 * time.Second),
				EndTime:        time.Now(),
				Metadata:       `{"db_queries": 15, "payloads_tested": 50}`,
			},
			wantErr: false,
		},
		{
			name: "failed plugin execution",
			stats: &PluginStats{
				PluginID:       "xss-scanner",
				ScanID:         "scan-002",
				ExecutionTime:  500,
				MemoryUsage:    33554432, // 32MB
				FindingsCount:  0,
				Status:         "failed",
				ErrorMessage:   "Connection timeout to target",
				StartTime:      time.Now().Add(-1 * time.Second),
				EndTime:        time.Now(),
				Metadata:       `{"error_code": "TIMEOUT", "retry_count": 3}`,
			},
			wantErr: false,
		},
		{
			name: "timeout plugin execution",
			stats: &PluginStats{
				PluginID:       "prompt-injection-scanner",
				ScanID:         "scan-003",
				ExecutionTime:  30000, // 30 seconds
				MemoryUsage:    134217728, // 128MB
				FindingsCount:  1,
				Status:         "timeout",
				ErrorMessage:   "Execution exceeded maximum timeout",
				StartTime:      time.Now().Add(-35 * time.Second),
				EndTime:        time.Now(),
				Metadata:       `{"timeout_threshold": 30000, "partial_results": true}`,
			},
			wantErr: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			err := dao.Create(ctx, tt.stats)

			if tt.wantErr {
				assert.Error(t, err)
				return
			}

			require.NoError(t, err)
			assert.NotEmpty(t, tt.stats.ID)
			assert.NotZero(t, tt.stats.CreatedAt)

			// Verify the stats were created
			created, err := dao.GetByID(ctx, tt.stats.ID)
			require.NoError(t, err)
			assert.NotNil(t, created)
			assert.Equal(t, tt.stats.PluginID, created.PluginID)
			assert.Equal(t, tt.stats.ScanID, created.ScanID)
			assert.Equal(t, tt.stats.Status, created.Status)
			assert.Equal(t, tt.stats.FindingsCount, created.FindingsCount)
		})
	}
}

func TestPluginStatsDAO_GetByPluginID(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	pluginID := "test-plugin"

	// Create multiple stats for the same plugin
	for i := 0; i < 10; i++ {
		stats := &PluginStats{
			PluginID:      pluginID,
			ScanID:        fmt.Sprintf("scan-%03d", i),
			ExecutionTime: int64(1000 + i*100),
			MemoryUsage:   int64(50000000 + i*1000000),
			FindingsCount: i % 3,
			Status:        "success",
			StartTime:     time.Now().Add(-time.Duration(i) * time.Minute),
			EndTime:       time.Now().Add(-time.Duration(i) * time.Minute + 2*time.Second),
			Metadata:      fmt.Sprintf(`{"run": %d}`, i),
		}

		err := dao.Create(ctx, stats)
		require.NoError(t, err)

		// Add slight delay to ensure different timestamps
		time.Sleep(1 * time.Millisecond)
	}

	tests := []struct {
		name        string
		limit       int
		offset      int
		expectedLen int
	}{
		{
			name:        "first page",
			limit:       5,
			offset:      0,
			expectedLen: 5,
		},
		{
			name:        "second page",
			limit:       5,
			offset:      5,
			expectedLen: 5,
		},
		{
			name:        "beyond available",
			limit:       5,
			offset:      15,
			expectedLen: 0,
		},
		{
			name:        "all stats",
			limit:       20,
			offset:      0,
			expectedLen: 10,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			results, err := dao.GetByPluginID(ctx, pluginID, tt.limit, tt.offset)
			require.NoError(t, err)
			assert.Len(t, results, tt.expectedLen)

			// Verify ordering (newest first)
			if len(results) > 1 {
				for i := 0; i < len(results)-1; i++ {
					assert.True(t, results[i].CreatedAt.After(results[i+1].CreatedAt) ||
						results[i].CreatedAt.Equal(results[i+1].CreatedAt))
				}
			}

			// Verify all results are for the correct plugin
			for _, result := range results {
				assert.Equal(t, pluginID, result.PluginID)
			}
		})
	}
}

func TestPluginStatsDAO_GetByScanID(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	scanID := "scan-integration-test"

	// Create stats for multiple plugins in the same scan
	plugins := []string{"plugin-a", "plugin-b", "plugin-c"}
	var expectedStats []*PluginStats

	for i, pluginID := range plugins {
		stats := &PluginStats{
			PluginID:      pluginID,
			ScanID:        scanID,
			ExecutionTime: int64(1000 + i*500),
			MemoryUsage:   int64(50000000 + i*10000000),
			FindingsCount: i + 1,
			Status:        "success",
			StartTime:     time.Now().Add(-time.Duration(len(plugins)-i) * time.Minute),
			EndTime:       time.Now().Add(-time.Duration(len(plugins)-i) * time.Minute + 2*time.Second),
			Metadata:      fmt.Sprintf(`{"plugin": "%s"}`, pluginID),
		}

		err := dao.Create(ctx, stats)
		require.NoError(t, err)
		expectedStats = append(expectedStats, stats)

		time.Sleep(1 * time.Millisecond)
	}

	// Get stats by scan ID
	results, err := dao.GetByScanID(ctx, scanID)
	require.NoError(t, err)
	assert.Len(t, results, len(plugins))

	// Verify ordering (by start_time)
	for i := 0; i < len(results)-1; i++ {
		assert.True(t, results[i].StartTime.Before(results[i+1].StartTime) ||
			results[i].StartTime.Equal(results[i+1].StartTime))
	}

	// Verify all results are for the correct scan
	for _, result := range results {
		assert.Equal(t, scanID, result.ScanID)
	}

	// Test with non-existent scan ID
	results, err = dao.GetByScanID(ctx, "non-existent-scan")
	require.NoError(t, err)
	assert.Len(t, results, 0)
}

func TestPluginStatsDAO_GetPerformanceMetrics(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	pluginID := "performance-test-plugin"

	// Create mixed success/failure stats with varying performance
	testStats := []struct {
		executionTime int64
		memoryUsage   int64
		findingsCount int
		status        string
	}{
		{1000, 50000000, 2, "success"},
		{1500, 60000000, 1, "success"},
		{2000, 70000000, 3, "success"},
		{500, 40000000, 0, "failed"},
		{3000, 80000000, 4, "success"},
		{800, 45000000, 0, "failed"},
		{1200, 55000000, 2, "success"},
		{10000, 100000000, 0, "timeout"},
	}

	for i, ts := range testStats {
		stats := &PluginStats{
			PluginID:      pluginID,
			ScanID:        fmt.Sprintf("scan-%d", i),
			ExecutionTime: ts.executionTime,
			MemoryUsage:   ts.memoryUsage,
			FindingsCount: ts.findingsCount,
			Status:        ts.status,
			StartTime:     time.Now().Add(-time.Duration(i) * time.Hour),
			EndTime:       time.Now().Add(-time.Duration(i) * time.Hour + time.Duration(ts.executionTime) * time.Millisecond),
		}

		err := dao.Create(ctx, stats)
		require.NoError(t, err)
	}

	// Get performance metrics
	metrics, err := dao.GetPerformanceMetrics(ctx, pluginID)
	require.NoError(t, err)
	assert.NotNil(t, metrics)

	// Verify metrics calculations
	assert.Equal(t, pluginID, metrics.PluginID)
	assert.Equal(t, 8, metrics.TotalExecutions)
	assert.Equal(t, 5, metrics.SuccessfulRuns) // 5 success
	assert.Equal(t, 2, metrics.FailedRuns)     // 2 failed (timeout counted separately)
	assert.Equal(t, int64(10000), metrics.MaxExecutionTime) // timeout case
	assert.Equal(t, int64(500), metrics.MinExecutionTime)   // fastest execution
	assert.Equal(t, int64(100000000), metrics.MaxMemoryUsage) // timeout case
	assert.Equal(t, 12, metrics.TotalFindings) // 2+1+3+4+2 = 12
	assert.InDelta(t, 62.5, metrics.SuccessRate, 0.1) // 5/8 * 100 = 62.5%

	// Test with non-existent plugin
	metrics, err = dao.GetPerformanceMetrics(ctx, "non-existent")
	require.NoError(t, err)
	assert.Nil(t, metrics)
}

func TestPluginStatsDAO_GetAllPerformanceMetrics(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	// Create stats for multiple plugins
	plugins := map[string]struct {
		successCount int
		failCount    int
	}{
		"fast-plugin":   {5, 1},
		"slow-plugin":   {3, 3},
		"reliable-plugin": {10, 0},
	}

	for pluginID, counts := range plugins {
		// Create success stats
		for i := 0; i < counts.successCount; i++ {
			stats := &PluginStats{
				PluginID:      pluginID,
				ScanID:        fmt.Sprintf("%s-scan-%d", pluginID, i),
				ExecutionTime: int64(1000 + i*100),
				MemoryUsage:   int64(50000000),
				FindingsCount: 1,
				Status:        "success",
				StartTime:     time.Now().Add(-time.Duration(i) * time.Hour),
				EndTime:       time.Now().Add(-time.Duration(i) * time.Hour + 1*time.Second),
			}
			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}

		// Create failure stats
		for i := 0; i < counts.failCount; i++ {
			stats := &PluginStats{
				PluginID:      pluginID,
				ScanID:        fmt.Sprintf("%s-fail-scan-%d", pluginID, i),
				ExecutionTime: int64(500),
				MemoryUsage:   int64(30000000),
				FindingsCount: 0,
				Status:        "failed",
				StartTime:     time.Now().Add(-time.Duration(i) * time.Hour),
				EndTime:       time.Now().Add(-time.Duration(i) * time.Hour + 500*time.Millisecond),
			}
			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}
	}

	// Get all performance metrics
	allMetrics, err := dao.GetAllPerformanceMetrics(ctx)
	require.NoError(t, err)
	assert.Len(t, allMetrics, len(plugins))

	// Verify each plugin's metrics
	metricsByPlugin := make(map[string]*PluginPerformanceMetrics)
	for _, metric := range allMetrics {
		metricsByPlugin[metric.PluginID] = metric
	}

	// Check reliable plugin (100% success rate)
	reliableMetrics := metricsByPlugin["reliable-plugin"]
	assert.NotNil(t, reliableMetrics)
	assert.Equal(t, 10, reliableMetrics.SuccessfulRuns)
	assert.Equal(t, 0, reliableMetrics.FailedRuns)
	assert.Equal(t, 100.0, reliableMetrics.SuccessRate)

	// Check slow plugin (50% success rate)
	slowMetrics := metricsByPlugin["slow-plugin"]
	assert.NotNil(t, slowMetrics)
	assert.Equal(t, 3, slowMetrics.SuccessfulRuns)
	assert.Equal(t, 3, slowMetrics.FailedRuns)
	assert.Equal(t, 50.0, slowMetrics.SuccessRate)
}

func TestPluginStatsDAO_TopPerformingPlugins(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	// Create plugins with different performance characteristics
	pluginData := []struct {
		pluginID       string
		successCount   int
		failCount      int
		avgFindings    int
	}{
		{"excellent-plugin", 10, 0, 5},    // 100% success, high findings
		{"good-plugin", 8, 2, 3},          // 80% success, medium findings
		{"average-plugin", 5, 5, 2},       // 50% success, low findings
		{"poor-plugin", 2, 8, 1},          // 20% success, very low findings
		{"unreliable-plugin", 1, 9, 0},    // 10% success, no findings
	}

	for _, pd := range pluginData {
		// Create enough executions to meet minimum threshold (5+)
		totalRuns := pd.successCount + pd.failCount

		for i := 0; i < pd.successCount; i++ {
			stats := &PluginStats{
				PluginID:      pd.pluginID,
				ScanID:        fmt.Sprintf("%s-success-%d", pd.pluginID, i),
				ExecutionTime: int64(1000 + i*100),
				MemoryUsage:   int64(50000000),
				FindingsCount: pd.avgFindings,
				Status:        "success",
				StartTime:     time.Now().Add(-time.Duration(totalRuns-i) * time.Hour),
				EndTime:       time.Now().Add(-time.Duration(totalRuns-i) * time.Hour + 1*time.Second),
			}
			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}

		for i := 0; i < pd.failCount; i++ {
			stats := &PluginStats{
				PluginID:      pd.pluginID,
				ScanID:        fmt.Sprintf("%s-fail-%d", pd.pluginID, i),
				ExecutionTime: int64(500),
				MemoryUsage:   int64(30000000),
				FindingsCount: 0,
				Status:        "failed",
				StartTime:     time.Now().Add(-time.Duration(pd.failCount-i) * time.Hour),
				EndTime:       time.Now().Add(-time.Duration(pd.failCount-i) * time.Hour + 500*time.Millisecond),
			}
			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}
	}

	// Get top performing plugins
	topPlugins, err := dao.GetTopPerformingPlugins(ctx, 3)
	require.NoError(t, err)
	assert.Len(t, topPlugins, 3)

	// Verify ordering (best performers first)
	assert.Equal(t, "excellent-plugin", topPlugins[0].PluginID)
	assert.Equal(t, 100.0, topPlugins[0].SuccessRate)

	assert.Equal(t, "good-plugin", topPlugins[1].PluginID)
	assert.Equal(t, 80.0, topPlugins[1].SuccessRate)

	assert.Equal(t, "average-plugin", topPlugins[2].PluginID)
	assert.Equal(t, 50.0, topPlugins[2].SuccessRate)
}

func TestPluginStatsDAO_SlowestPlugins(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	// Create plugins with different execution times
	pluginTimes := map[string][]int64{
		"very-slow-plugin": {5000, 6000, 7000}, // avg: 6000ms
		"slow-plugin":      {3000, 3500, 4000}, // avg: 3500ms
		"fast-plugin":      {500, 600, 700},    // avg: 600ms
		"ultra-fast-plugin": {100, 150, 200},   // avg: 150ms
	}

	for pluginID, times := range pluginTimes {
		for i, execTime := range times {
			stats := &PluginStats{
				PluginID:      pluginID,
				ScanID:        fmt.Sprintf("%s-scan-%d", pluginID, i),
				ExecutionTime: execTime,
				MemoryUsage:   int64(50000000),
				FindingsCount: 1,
				Status:        "success",
				StartTime:     time.Now().Add(-time.Duration(i) * time.Hour),
				EndTime:       time.Now().Add(-time.Duration(i) * time.Hour + time.Duration(execTime)*time.Millisecond),
			}
			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}
	}

	// Get slowest plugins
	slowestPlugins, err := dao.GetSlowestPlugins(ctx, 2)
	require.NoError(t, err)
	assert.Len(t, slowestPlugins, 2)

	// Verify ordering (slowest first)
	assert.Equal(t, "very-slow-plugin", slowestPlugins[0].PluginID)
	assert.InDelta(t, 6000.0, slowestPlugins[0].AvgExecutionTime, 1.0)

	assert.Equal(t, "slow-plugin", slowestPlugins[1].PluginID)
	assert.InDelta(t, 3500.0, slowestPlugins[1].AvgExecutionTime, 1.0)
}

func TestPluginStatsDAO_TimeRangeStats(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	pluginID := "time-range-test-plugin"
	baseTime := time.Now().Truncate(time.Hour)

	// Create stats across different hours
	for hour := 0; hour < 5; hour++ {
		for execution := 0; execution < 3; execution++ {
			status := "success"
			findings := 2
			if execution == 2 { // Make every 3rd execution fail
				status = "failed"
				findings = 0
			}

			stats := &PluginStats{
				PluginID:      pluginID,
				ScanID:        fmt.Sprintf("scan-%d-%d", hour, execution),
				ExecutionTime: int64(1000 + execution*100),
				MemoryUsage:   int64(50000000),
				FindingsCount: findings,
				Status:        status,
				StartTime:     baseTime.Add(time.Duration(hour) * time.Hour),
				EndTime:       baseTime.Add(time.Duration(hour) * time.Hour + 1*time.Second),
			}
			stats.CreatedAt = baseTime.Add(time.Duration(hour) * time.Hour + time.Duration(execution) * time.Minute)

			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}
	}

	// Test time range stats
	start := baseTime
	end := baseTime.Add(5 * time.Hour)

	timeStats, err := dao.GetTimeRangeStats(ctx, pluginID, start, end)
	require.NoError(t, err)
	assert.Len(t, timeStats, 5) // 5 hours of data

	// Verify each hour has correct stats
	for i, stat := range timeStats {
		assert.Equal(t, 3, stat.ExecutionCount) // 3 executions per hour
		assert.Equal(t, 2, stat.SuccessCount)   // 2 successes per hour
		assert.Equal(t, 1, stat.FailureCount)   // 1 failure per hour
		assert.Equal(t, 4, stat.TotalFindings)  // 2 findings × 2 successes = 4
	}
}

func TestPluginStatsDAO_DeleteOldStats(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	cutoffTime := time.Now().Add(-24 * time.Hour)

	// Create old stats (before cutoff)
	for i := 0; i < 5; i++ {
		stats := &PluginStats{
			PluginID:      "old-plugin",
			ScanID:        fmt.Sprintf("old-scan-%d", i),
			ExecutionTime: 1000,
			MemoryUsage:   50000000,
			FindingsCount: 1,
			Status:        "success",
			StartTime:     cutoffTime.Add(-time.Duration(i+1) * time.Hour),
			EndTime:       cutoffTime.Add(-time.Duration(i+1) * time.Hour + 1*time.Second),
		}
		stats.CreatedAt = cutoffTime.Add(-time.Duration(i+1) * time.Hour)

		err := dao.Create(ctx, stats)
		require.NoError(t, err)
	}

	// Create new stats (after cutoff)
	for i := 0; i < 3; i++ {
		stats := &PluginStats{
			PluginID:      "new-plugin",
			ScanID:        fmt.Sprintf("new-scan-%d", i),
			ExecutionTime: 1000,
			MemoryUsage:   50000000,
			FindingsCount: 1,
			Status:        "success",
			StartTime:     cutoffTime.Add(time.Duration(i+1) * time.Hour),
			EndTime:       cutoffTime.Add(time.Duration(i+1) * time.Hour + 1*time.Second),
		}
		stats.CreatedAt = cutoffTime.Add(time.Duration(i+1) * time.Hour)

		err := dao.Create(ctx, stats)
		require.NoError(t, err)
	}

	// Verify we have 8 total stats
	allMetrics, err := dao.GetAllPerformanceMetrics(ctx)
	require.NoError(t, err)
	totalStats := 0
	for _, metric := range allMetrics {
		totalStats += metric.TotalExecutions
	}
	assert.Equal(t, 8, totalStats)

	// Delete old stats
	deletedCount, err := dao.DeleteOldStats(ctx, cutoffTime)
	require.NoError(t, err)
	assert.Equal(t, int64(5), deletedCount)

	// Verify only new stats remain
	allMetrics, err = dao.GetAllPerformanceMetrics(ctx)
	require.NoError(t, err)
	totalStats = 0
	for _, metric := range allMetrics {
		totalStats += metric.TotalExecutions
		assert.Equal(t, "new-plugin", metric.PluginID) // Only new plugin should remain
	}
	assert.Equal(t, 3, totalStats)
}

func TestPluginStatsDAO_Integration(t *testing.T) {
	testDB := test.NewTestDatabase(t)
	defer testDB.Close()

	testDB.CreateTestTables(t)
	require.NoError(t, CreatePluginStatsTable(testDB.DB))

	dao := NewSQLitePluginStatsDAO(testDB.DB)
	ctx := context.Background()

	// Integration test: Create comprehensive plugin execution history
	plugins := []string{"sql-scanner", "xss-scanner", "ai-safety-scanner"}
	scanID := "integration-scan-001"

	// Create execution stats for each plugin
	for i, pluginID := range plugins {
		// Create multiple executions with varying performance
		executions := []struct {
			status        string
			execTime      int64
			memUsage      int64
			findingsCount int
			errorMsg      string
		}{
			{"success", 1000, 50000000, 3, ""},
			{"success", 1200, 55000000, 2, ""},
			{"failed", 500, 30000000, 0, "Connection refused"},
			{"success", 1500, 60000000, 4, ""},
			{"timeout", 30000, 100000000, 1, "Execution timeout"},
		}

		for j, exec := range executions {
			stats := &PluginStats{
				PluginID:      pluginID,
				ScanID:        fmt.Sprintf("%s-run-%d", scanID, j),
				ExecutionTime: exec.execTime,
				MemoryUsage:   exec.memUsage,
				FindingsCount: exec.findingsCount,
				Status:        exec.status,
				ErrorMessage:  exec.errorMsg,
				StartTime:     time.Now().Add(-time.Duration((len(plugins)-i)*len(executions)+j) * time.Minute),
				EndTime:       time.Now().Add(-time.Duration((len(plugins)-i)*len(executions)+j) * time.Minute + time.Duration(exec.execTime)*time.Millisecond),
				Metadata:      fmt.Sprintf(`{"plugin": "%s", "execution": %d}`, pluginID, j),
			}

			err := dao.Create(ctx, stats)
			require.NoError(t, err)
		}
	}

	// Test 1: Get scan statistics
	for i := 0; i < 5; i++ {
		scanStats, err := dao.GetByScanID(ctx, fmt.Sprintf("%s-run-%d", scanID, i))
		require.NoError(t, err)
		assert.Len(t, scanStats, len(plugins)) // Each scan should have stats for all plugins

		// Verify proper ordering by start time
		if len(scanStats) > 1 {
			for j := 0; j < len(scanStats)-1; j++ {
				assert.True(t, scanStats[j].StartTime.Before(scanStats[j+1].StartTime) ||
					scanStats[j].StartTime.Equal(scanStats[j+1].StartTime))
			}
		}
	}

	// Test 2: Performance metrics for each plugin
	for _, pluginID := range plugins {
		metrics, err := dao.GetPerformanceMetrics(ctx, pluginID)
		require.NoError(t, err)
		assert.NotNil(t, metrics)
		assert.Equal(t, pluginID, metrics.PluginID)
		assert.Equal(t, 5, metrics.TotalExecutions)
		assert.Equal(t, 3, metrics.SuccessfulRuns)
		assert.Equal(t, 1, metrics.FailedRuns)
		assert.Equal(t, int64(30000), metrics.MaxExecutionTime) // timeout case
		assert.Equal(t, int64(500), metrics.MinExecutionTime)   // failed case (fastest)
		assert.Equal(t, 9, metrics.TotalFindings)               // 3+2+0+4+1 = 10, but 0 from failed
		assert.InDelta(t, 60.0, metrics.SuccessRate, 0.1)      // 3/5 * 100 = 60%
	}

	// Test 3: Get all performance metrics
	allMetrics, err := dao.GetAllPerformanceMetrics(ctx)
	require.NoError(t, err)
	assert.Len(t, allMetrics, len(plugins))

	// Test 4: Top performing plugins
	topPlugins, err := dao.GetTopPerformingPlugins(ctx, 2)
	require.NoError(t, err)
	assert.Len(t, topPlugins, 2) // Since minimum execution threshold is met

	// Test 5: Most active plugins
	activePlugins, err := dao.GetMostActivePlugins(ctx, 3)
	require.NoError(t, err)
	assert.Len(t, activePlugins, 3)
	for _, plugin := range activePlugins {
		assert.Equal(t, 5, plugin.TotalExecutions)
	}

	// Test 6: Daily stats
	today := time.Now()
	dailyStats, err := dao.GetDailyStats(ctx, today)
	require.NoError(t, err)
	if len(dailyStats) > 0 {
		totalExecutions := 0
		for _, stat := range dailyStats {
			totalExecutions += stat.ExecutionCount
		}
		assert.Equal(t, len(plugins)*5, totalExecutions) // 3 plugins × 5 executions each
	}

	// Test 7: Time range stats for specific plugin
	start := time.Now().Add(-2 * time.Hour)
	end := time.Now().Add(1 * time.Hour)

	timeStats, err := dao.GetTimeRangeStats(ctx, plugins[0], start, end)
	require.NoError(t, err)
	// Should have some stats in this range

	// Test 8: Verify data integrity across operations
	pluginStats, err := dao.GetByPluginID(ctx, plugins[0], 10, 0)
	require.NoError(t, err)
	assert.Len(t, pluginStats, 5)

	// All stats should belong to the correct plugin
	for _, stat := range pluginStats {
		assert.Equal(t, plugins[0], stat.PluginID)
		assert.NotEmpty(t, stat.ID)
		assert.NotZero(t, stat.CreatedAt)
	}
}